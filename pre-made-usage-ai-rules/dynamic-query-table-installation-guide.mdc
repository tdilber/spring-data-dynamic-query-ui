# Spring Dynamic Query UI - Complete Installation Guide

This guide provides step-by-step instructions to install and set up the Dynamic Query Table component in your Next.js project from scratch.

## Prerequisites

- Node.js 18+ installed
- Next.js 14+ project with App Router
- TypeScript enabled

## Step 1: Install Dependencies

Install all required dependencies:

```bash
npm install react react-dom next date-fns zustand react-hook-form zod @hookform/resolvers clsx tailwind-merge class-variance-authority lucide-react @radix-ui/react-dialog @radix-ui/react-select @radix-ui/react-checkbox @radix-ui/react-popover @radix-ui/react-label @radix-ui/react-slot cmdk react-day-picker
```

Install development dependencies:

```bash
npm install -D typescript @types/node @types/react @types/react-dom autoprefixer postcss tailwindcss tailwindcss-animate eslint eslint-config-next
```

## Step 2: Configure TypeScript

Create or update `tsconfig.json`:

```json
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
```

## Step 3: Configure Tailwind CSS

Create `tailwind.config.ts`:

```typescript
import type { Config } from "tailwindcss"

const config = {
  darkMode: ["class"],
  content: [
    './pages/**/*.{ts,tsx}',
    './components/**/*.{ts,tsx}',
    './app/**/*.{ts,tsx}',
    './src/**/*.{ts,tsx}',
	],
  prefix: "",
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
} satisfies Config

export default config
```

Create `postcss.config.js`:

```javascript
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
```

## Step 4: Create Global Styles

Create `app/globals.css`:

```css
@tailwind base;
@tailwind components;
@tailwind utilities;
 
@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;

    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
 
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
 
    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;
 
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
 
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
 
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
 
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;

    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 222.2 84% 4.9%;
 
    --radius: 0.5rem;
  }
 
  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
 
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
 
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
 
    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;
 
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
 
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
 
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
 
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
 
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 212.7 26.8% 83.9%;
  }
}
 
@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}
```

## Step 5: Create shadcn/ui Configuration

Create `components.json`:

```json
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "app/globals.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui"
  }
}
```

## Step 6: Create Utility Files

Create `lib/utils/cn.ts`:

```typescript
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
```

## Step 7: Install shadcn/ui Components

Run these commands to install required UI components:

```bash
npx shadcn-ui@latest add badge
npx shadcn-ui@latest add button
npx shadcn-ui@latest add calendar
npx shadcn-ui@latest add checkbox
npx shadcn-ui@latest add dialog
npx shadcn-ui@latest add input
npx shadcn-ui@latest add label
npx shadcn-ui@latest add popover
npx shadcn-ui@latest add select
npx shadcn-ui@latest add table
```

## Step 8: Create Type Definitions

Create `lib/types/field.types.ts`:

```typescript
import { ReactNode } from "react";

export enum CriteriaOperation {
  CONTAIN = "CONTAIN",
  DOES_NOT_CONTAIN = "DOES_NOT_CONTAIN",
  END_WITH = "END_WITH",
  START_WITH = "START_WITH",
  SPECIFIED = "SPECIFIED",
  EQUAL = "EQUAL",
  NOT_EQUAL = "NOT_EQUAL",
  GREATER_THAN = "GREATER_THAN",
  GREATER_THAN_OR_EQUAL = "GREATER_THAN_OR_EQUAL",
  LESS_THAN = "LESS_THAN",
  LESS_THAN_OR_EQUAL = "LESS_THAN_OR_EQUAL",
}

export interface Criteria {
  key: string;
  operation: CriteriaOperation;
  values: string[];
}

export interface DynamicQuery {
  criteria: Criteria[];
  select?: string[];
  selectAs?: string[];
  orderBy?: string[];
  orderByDirection?: ("asc" | "desc")[];
  page?: number;
  pageSize?: number;
}

export interface SpringPage<T> {
  content: T[];
  pageable: {
    pageNumber: number;
    pageSize: number;
    sort: {
      sorted: boolean;
      unsorted: boolean;
      empty: boolean;
    };
    offset: number;
    paged: boolean;
    unpaged: boolean;
  };
  totalPages: number;
  totalElements: number;
  last: boolean;
  size: number;
  number: number;
  sort: {
    sorted: boolean;
    unsorted: boolean;
    empty: boolean;
  };
  numberOfElements: number;
  first: boolean;
  empty: boolean;
}

export interface BaseField<T = any> {
  name: string;
  title: string;
  visible?: boolean;
  filterable?: boolean;
  sortable?: boolean;
  showInDetail?: boolean;
  editable?: boolean;
  accessor?: string;
  placeholder?: string;
  defaultValue?: T;
  renderCell?: (value: T, row: any) => ReactNode;
  renderEdit?: (value: T, onChange: (val: T) => void, row?: any) => ReactNode;
}

export interface StringField extends BaseField<string> {
  type: "String";
}

export interface IntegerField extends BaseField<number> {
  type: "Integer";
}

export interface BooleanField extends BaseField<boolean> {
  type: "Boolean";
}

export interface DateField extends BaseField<Date | string> {
  type: "Date";
}

export interface DateSecField extends BaseField<number> {
  type: "DateSec";
}

export interface DateTimeSecField extends BaseField<number> {
  type: "DateTimeSec";
}

export interface EnumField extends BaseField<string> {
  type: "Enum";
  enumValues: Record<string, string>;
  multiSelect?: boolean;
}

export interface ImageField extends BaseField<string> {
  type: "Image";
  uploadConfig: string;
  maxSize?: number;
  allowedTypes?: string[];
}

export interface RichTextField extends BaseField<string> {
  type: "RichText";
  editorConfig?: Record<string, any>;
}

export type Field =
  | StringField
  | IntegerField
  | BooleanField
  | DateField
  | DateSecField
  | DateTimeSecField
  | EnumField
  | ImageField
  | RichTextField;

export type FieldValue<T extends Field> = T extends BaseField<infer V>
  ? V
  : never;

export type InferRowData<T extends Field[]> = {
  [K in T[number]["name"]]: FieldValue<Extract<T[number], { name: K }>>;
};
```

## Step 9: Create Query Builder Utility

Create `lib/utils/query-builder.ts`:

```typescript
import { Criteria, CriteriaOperation, DynamicQuery } from "../types/field.types";

const KEY_FIELD = "key";
const OPERATION_FIELD = "operation";
const VALUES_FIELD = "values";

export class QueryBuilder {
  private _dynamicQuery: DynamicQuery;

  constructor(initialQuery?: DynamicQuery) {
    this._dynamicQuery = initialQuery || {
      criteria: [],
      page: 0,
      pageSize: 20,
    };
  }

  get query(): DynamicQuery {
    return this._dynamicQuery;
  }

  set query(query: DynamicQuery) {
    this._dynamicQuery = query;
  }

  toQueryString(): string {
    const params = new URLSearchParams();

    this._dynamicQuery.criteria.forEach((criteria, idx) => {
      params.append(`${KEY_FIELD}${idx}`, criteria.key);
      params.append(`${OPERATION_FIELD}${idx}`, criteria.operation);
      criteria.values.forEach((value) => {
        params.append(`${VALUES_FIELD}${idx}`, value);
      });
    });

    if (this._dynamicQuery.select && this._dynamicQuery.select.length > 0) {
      this._dynamicQuery.select.forEach((field, idx) => {
        params.append(`select${idx}`, field);
      });
    }

    if (this._dynamicQuery.selectAs && this._dynamicQuery.selectAs.length > 0) {
      this._dynamicQuery.selectAs.forEach((alias, idx) => {
        params.append(`selectAs${idx}`, alias);
      });
    }

    if (this._dynamicQuery.orderBy && this._dynamicQuery.orderBy.length > 0) {
      this._dynamicQuery.orderBy.forEach((field, idx) => {
        params.append(`orderBy${idx}`, field);
      });
    }

    if (
      this._dynamicQuery.orderByDirection &&
      this._dynamicQuery.orderByDirection.length > 0
    ) {
      this._dynamicQuery.orderByDirection.forEach((direction, idx) => {
        params.append(`orderByDirection${idx}`, direction);
      });
    }

    if (this._dynamicQuery.page !== undefined) {
      params.append("page", this._dynamicQuery.page.toString());
    }

    if (this._dynamicQuery.pageSize !== undefined) {
      params.append("pageSize", this._dynamicQuery.pageSize.toString());
    }

    return params.toString();
  }

  fromQueryString(queryString: string): DynamicQuery {
    const params = new URLSearchParams(queryString);
    const criteria: Criteria[] = [];
    const select: string[] = [];
    const selectAs: string[] = [];
    const orderBy: string[] = [];
    const orderByDirection: ("asc" | "desc")[] = [];

    const criteriaMap = new Map<number, Partial<Criteria>>();

    params.forEach((value, key) => {
      const keyMatch = key.match(/^key(\d+)$/);
      const operationMatch = key.match(/^operation(\d+)$/);
      const valuesMatch = key.match(/^values(\d+)$/);

      if (keyMatch) {
        const idx = parseInt(keyMatch[1], 10);
        if (!criteriaMap.has(idx)) {
          criteriaMap.set(idx, {});
        }
        criteriaMap.get(idx)!.key = value;
      } else if (operationMatch) {
        const idx = parseInt(operationMatch[1], 10);
        if (!criteriaMap.has(idx)) {
          criteriaMap.set(idx, {});
        }
        criteriaMap.get(idx)!.operation = value as CriteriaOperation;
      } else if (valuesMatch) {
        const idx = parseInt(valuesMatch[1], 10);
        if (!criteriaMap.has(idx)) {
          criteriaMap.set(idx, { values: [] });
        }
        if (!criteriaMap.get(idx)!.values) {
          criteriaMap.get(idx)!.values = [];
        }
        const splitValues = decodeURIComponent(value).split("&&");
        criteriaMap.get(idx)!.values!.push(...splitValues);
      }

      const selectMatch = key.match(/^select(\d+)$/);
      if (selectMatch) {
        const idx = parseInt(selectMatch[1], 10);
        select[idx] = value;
      }

      const selectAsMatch = key.match(/^selectAs(\d+)$/);
      if (selectAsMatch) {
        const idx = parseInt(selectAsMatch[1], 10);
        selectAs[idx] = value;
      }

      const orderByMatch = key.match(/^orderBy(\d+)$/);
      if (orderByMatch) {
        const idx = parseInt(orderByMatch[1], 10);
        orderBy[idx] = value;
      }

      const orderByDirectionMatch = key.match(/^orderByDirection(\d+)$/);
      if (orderByDirectionMatch) {
        const idx = parseInt(orderByDirectionMatch[1], 10);
        orderByDirection[idx] = value as "asc" | "desc";
      }
    });

    criteriaMap.forEach((criteriaObj) => {
      if (criteriaObj.key && criteriaObj.operation && criteriaObj.values) {
        criteria.push({
          key: criteriaObj.key,
          operation: criteriaObj.operation,
          values: criteriaObj.values,
        });
      }
    });

    this._dynamicQuery = {
      criteria,
      select: select.length > 0 ? select : undefined,
      selectAs: selectAs.length > 0 ? selectAs : undefined,
      orderBy: orderBy.length > 0 ? orderBy : undefined,
      orderByDirection:
        orderByDirection.length > 0 ? orderByDirection : undefined,
      page: params.has("page") ? parseInt(params.get("page")!, 10) : undefined,
      pageSize: params.has("pageSize")
        ? parseInt(params.get("pageSize")!, 10)
        : undefined,
    };

    return this._dynamicQuery;
  }

  addCriteria(key: string, operation: CriteriaOperation, values: string[]): void {
    this._dynamicQuery.criteria.push({
      key,
      operation,
      values,
    });
  }

  removeCriteria(key: string, operation?: CriteriaOperation): void {
    this._dynamicQuery.criteria = this._dynamicQuery.criteria.filter(
      (c) => c.key !== key || (operation && c.operation !== operation)
    );
  }

  removeCriteriaByKey(key: string): void {
    this._dynamicQuery.criteria = this._dynamicQuery.criteria.filter(
      (c) => c.key !== key
    );
  }

  upsertCriteria(
    key: string,
    operation: CriteriaOperation,
    values: string[]
  ): void {
    this.removeCriteria(key, operation);
    this.addCriteria(key, operation, values);
  }

  setPage(page: number): void {
    this._dynamicQuery.page = page;
  }

  setPageSize(pageSize: number): void {
    this._dynamicQuery.pageSize = pageSize;
  }

  setSort(field: string, direction: "asc" | "desc"): void {
    this._dynamicQuery.orderBy = [field];
    this._dynamicQuery.orderByDirection = [direction];
  }

  clearSort(): void {
    this._dynamicQuery.orderBy = undefined;
    this._dynamicQuery.orderByDirection = undefined;
  }

  clearCriteria(): void {
    this._dynamicQuery.criteria = [];
  }

  clear(): void {
    this._dynamicQuery = {
      criteria: [],
      page: 0,
      pageSize: 20,
    };
  }

  getCriteriaValues(key: string, operation?: CriteriaOperation): string[] {
    const criteria = this._dynamicQuery.criteria.filter(
      (c) => c.key === key && (!operation || c.operation === operation)
    );
    return criteria.flatMap((c) => c.values);
  }

  hasCriteria(key: string, operation?: CriteriaOperation): boolean {
    return this._dynamicQuery.criteria.some(
      (c) => c.key === key && (!operation || c.operation === operation)
    );
  }
}

export function createQueryBuilder(initialQuery?: DynamicQuery): QueryBuilder {
  return new QueryBuilder(initialQuery);
}

export function parseQueryString(queryString: string): DynamicQuery {
  const builder = new QueryBuilder();
  return builder.fromQueryString(queryString);
}

export function toQueryString(query: DynamicQuery): string {
  const builder = new QueryBuilder(query);
  return builder.toQueryString();
}
```

## Step 10: Create Component Files

Create the directory structure:

```
components/
  dynamic-query-table/
    filter.tsx
    table.tsx
    form.tsx
    detail-view.tsx
    pagination.tsx
    index.ts
```

Create `components/dynamic-query-table/filter.tsx`:

```typescript
"use client";

import React, { useEffect, useState } from "react";
import { Filter, ChevronDown, ChevronUp, Pin } from "lucide-react";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Checkbox } from "@/components/ui/checkbox";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { Calendar } from "@/components/ui/calendar";
import { cn } from "@/lib/utils/cn";
import { Field, CriteriaOperation } from "@/lib/types/field.types";
import { QueryBuilder } from "@/lib/utils/query-builder";
import { format } from "date-fns";

interface FilterPanelProps {
  fields: Field[];
  queryBuilder: QueryBuilder;
  onFilterChange: () => void;
}

export function FilterPanel({
  fields,
  queryBuilder,
  onFilterChange,
}: FilterPanelProps) {
  const [isExpanded, setIsExpanded] = useState(false);
  const [isPinned, setIsPinned] = useState(false);
  const [dateRanges, setDateRanges] = useState<Record<string, { from?: Date; to?: Date }>>({});

  useEffect(() => {
    const savedPinState = localStorage.getItem("filterPinned");
    if (savedPinState) {
      const pinned = JSON.parse(savedPinState);
      setIsPinned(pinned);
      if (pinned) {
        setIsExpanded(true);
      }
    }
  }, []);

  const filterableFields = fields.filter((f) => f.filterable);
  const activeFilterCount = queryBuilder.query.criteria.length;

  const toggleExpand = () => {
    if (!isPinned) {
      setIsExpanded(!isExpanded);
    }
  };

  const togglePin = (e: React.MouseEvent) => {
    e.stopPropagation();
    const newPinState = !isPinned;
    setIsPinned(newPinState);
    if (newPinState) {
      setIsExpanded(true);
    }
    localStorage.setItem("filterPinned", JSON.stringify(newPinState));
  };

  const handleStringFilter = (field: Field, value: string) => {
    const fieldName = field.accessor || field.name;
    if (value) {
      queryBuilder.upsertCriteria(fieldName, CriteriaOperation.CONTAIN, [value]);
    } else {
      queryBuilder.removeCriteriaByKey(fieldName);
    }
    onFilterChange();
  };

  const handleIntegerFilter = (field: Field, value: string) => {
    const fieldName = field.accessor || field.name;
    if (value) {
      queryBuilder.upsertCriteria(fieldName, CriteriaOperation.EQUAL, [value]);
    } else {
      queryBuilder.removeCriteriaByKey(fieldName);
    }
    onFilterChange();
  };

  const handleBooleanFilter = (field: Field, checked: boolean) => {
    const fieldName = field.accessor || field.name;
    if (checked) {
      queryBuilder.upsertCriteria(fieldName, CriteriaOperation.SPECIFIED, ["true"]);
    } else {
      queryBuilder.removeCriteriaByKey(fieldName);
    }
    onFilterChange();
  };

  const handleEnumFilter = (field: Field & { type: "Enum" }, value: string) => {
    const fieldName = field.accessor || field.name;
    if (value) {
      queryBuilder.upsertCriteria(fieldName, CriteriaOperation.EQUAL, [value]);
    } else {
      queryBuilder.removeCriteriaByKey(fieldName);
    }
    onFilterChange();
  };

  const handleDateRangeFilter = (field: Field, range: { from?: Date; to?: Date }) => {
    const fieldName = field.accessor || field.name;
    setDateRanges({ ...dateRanges, [fieldName]: range });

    queryBuilder.removeCriteriaByKey(fieldName);

    if (range.from) {
      const value = field.type === "DateSec" || field.type === "DateTimeSec"
        ? Math.floor(range.from.getTime() / 1000).toString()
        : range.from.toISOString();
      queryBuilder.addCriteria(
        fieldName,
        CriteriaOperation.GREATER_THAN_OR_EQUAL,
        [value]
      );
    }

    if (range.to) {
      const value = field.type === "DateSec" || field.type === "DateTimeSec"
        ? Math.floor(range.to.getTime() / 1000).toString()
        : range.to.toISOString();
      queryBuilder.addCriteria(
        fieldName,
        CriteriaOperation.LESS_THAN_OR_EQUAL,
        [value]
      );
    }

    onFilterChange();
  };

  const getFilterValue = (field: Field): string => {
    const fieldName = field.accessor || field.name;
    const values = queryBuilder.getCriteriaValues(fieldName);
    return values[0] || "";
  };

  const getBooleanValue = (field: Field): boolean => {
    const fieldName = field.accessor || field.name;
    return queryBuilder.hasCriteria(fieldName, CriteriaOperation.SPECIFIED);
  };

  const renderFilterInput = (field: Field) => {
    const fieldName = field.accessor || field.name;

    switch (field.type) {
      case "String":
      case "RichText":
        return (
          <Input
            placeholder={field.placeholder || `Filter ${field.title}...`}
            value={getFilterValue(field)}
            onChange={(e) => handleStringFilter(field, e.target.value)}
          />
        );

      case "Integer":
        return (
          <Input
            type="number"
            placeholder={field.placeholder || `Filter ${field.title}...`}
            value={getFilterValue(field)}
            onChange={(e) => handleIntegerFilter(field, e.target.value)}
          />
        );

      case "Boolean":
        return (
          <div className="flex items-center space-x-2">
            <Checkbox
              id={`filter-${fieldName}`}
              checked={getBooleanValue(field)}
              onCheckedChange={(checked) =>
                handleBooleanFilter(field, checked as boolean)
              }
            />
            <label
              htmlFor={`filter-${fieldName}`}
              className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
            >
              {field.title}
            </label>
          </div>
        );

      case "Enum":
        return (
          <Select
            value={getFilterValue(field) || undefined}
            onValueChange={(value) => handleEnumFilter(field, value)}
          >
            <SelectTrigger>
              <SelectValue placeholder={`Select ${field.title}`} />
            </SelectTrigger>
            <SelectContent>
              {Object.entries(field.enumValues).map(([key, label]) => (
                <SelectItem key={key} value={key}>
                  {label}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        );

      case "Date":
      case "DateSec":
      case "DateTimeSec":
        const currentRange = dateRanges[fieldName] || {};
        return (
          <Popover>
            <PopoverTrigger asChild>
              <Button variant="outline" className="w-full justify-start text-left font-normal">
                {currentRange.from ? (
                  currentRange.to ? (
                    <>
                      {format(currentRange.from, "LLL dd, y")} -{" "}
                      {format(currentRange.to, "LLL dd, y")}
                    </>
                  ) : (
                    format(currentRange.from, "LLL dd, y")
                  )
                ) : (
                  <span>Pick a date range</span>
                )}
              </Button>
            </PopoverTrigger>
            <PopoverContent className="w-auto p-0" align="start">
              <Calendar
                mode="range"
                selected={currentRange}
                onSelect={(range) =>
                  handleDateRangeFilter(field, range || {})
                }
                numberOfMonths={2}
              />
            </PopoverContent>
          </Popover>
        );

      case "Image":
        return (
          <Input
            placeholder="Filter by image URL..."
            value={getFilterValue(field)}
            onChange={(e) => handleStringFilter(field, e.target.value)}
          />
        );

      default:
        return null;
    }
  };

  return (
    <div className="border rounded-lg mb-4">
      <div
        className="flex items-center justify-between p-4 cursor-pointer hover:bg-muted/50"
        onClick={toggleExpand}
      >
        <div className="flex items-center gap-2">
          <Filter className="h-4 w-4" />
          <span className="font-medium">Filters</span>
          {activeFilterCount > 0 && (
            <Badge variant="secondary">{activeFilterCount}</Badge>
          )}
          {isExpanded ? (
            <ChevronUp className="h-4 w-4" />
          ) : (
            <ChevronDown className="h-4 w-4" />
          )}
        </div>
        <Button
          variant="ghost"
          size="icon"
          onClick={togglePin}
          className={cn(isPinned && "text-primary")}
        >
          <Pin
            className={cn(
              "h-4 w-4 transition-transform",
              isPinned ? "rotate-0" : "rotate-45"
            )}
          />
        </Button>
      </div>

      {isExpanded && (
        <div className="p-4 border-t space-y-4">
          {filterableFields.map((field) => (
            <div key={field.name} className="space-y-2">
              {field.type !== "Boolean" && (
                <Label htmlFor={`filter-${field.accessor || field.name}`}>
                  {field.title}
                </Label>
              )}
              {renderFilterInput(field)}
            </div>
          ))}
        </div>
      )}
    </div>
  );
}
```

Create `components/dynamic-query-table/pagination.tsx`:

```typescript
"use client";

import React from "react";
import { ChevronLeft, ChevronRight } from "lucide-react";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { SpringPage } from "@/lib/types/field.types";

interface PaginationProps {
  page: SpringPage<any>;
  onPageChange: (page: number) => void;
  onPageSizeChange: (pageSize: number) => void;
}

export function Pagination({
  page,
  onPageChange,
  onPageSizeChange,
}: PaginationProps) {
  const currentPage = page.number;
  const totalPages = page.totalPages;
  const totalElements = page.totalElements;
  const pageSize = page.size;
  const startItem = currentPage * pageSize + 1;
  const endItem = Math.min((currentPage + 1) * pageSize, totalElements);

  const getPageNumbers = () => {
    const pages: (number | string)[] = [];
    const maxVisible = 7;

    if (totalPages <= maxVisible) {
      for (let i = 0; i < totalPages; i++) {
        pages.push(i);
      }
    } else {
      pages.push(0);

      if (currentPage <= 3) {
        for (let i = 1; i <= 5; i++) {
          pages.push(i);
        }
        pages.push("...");
        pages.push(totalPages - 1);
      } else if (currentPage >= totalPages - 4) {
        pages.push("...");
        for (let i = totalPages - 6; i < totalPages; i++) {
          pages.push(i);
        }
      } else {
        pages.push("...");
        for (let i = currentPage - 1; i <= currentPage + 1; i++) {
          pages.push(i);
        }
        pages.push("...");
        pages.push(totalPages - 1);
      }
    }

    return pages;
  };

  return (
    <div className="flex items-center justify-between px-2 py-4">
      <div className="flex items-center gap-4">
        <div className="text-sm text-muted-foreground">
          Showing {startItem} to {endItem} of {totalElements} results
        </div>
        <div className="flex items-center gap-2">
          <span className="text-sm text-muted-foreground">Items per page:</span>
          <Select
            value={pageSize.toString()}
            onValueChange={(value) => onPageSizeChange(parseInt(value, 10))}
          >
            <SelectTrigger className="w-[70px]">
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="10">10</SelectItem>
              <SelectItem value="20">20</SelectItem>
              <SelectItem value="50">50</SelectItem>
              <SelectItem value="100">100</SelectItem>
            </SelectContent>
          </Select>
        </div>
      </div>

      <div className="flex items-center gap-2">
        <Button
          variant="outline"
          size="icon"
          onClick={() => onPageChange(currentPage - 1)}
          disabled={currentPage === 0}
        >
          <ChevronLeft className="h-4 w-4" />
        </Button>

        {getPageNumbers().map((pageNum, idx) => {
          if (pageNum === "...") {
            return (
              <span key={`ellipsis-${idx}`} className="px-2">
                ...
              </span>
            );
          }

          const isCurrentPage = pageNum === currentPage;
          return (
            <Button
              key={pageNum}
              variant={isCurrentPage ? "default" : "outline"}
              size="icon"
              onClick={() => onPageChange(pageNum as number)}
            >
              {(pageNum as number) + 1}
            </Button>
          );
        })}

        <Button
          variant="outline"
          size="icon"
          onClick={() => onPageChange(currentPage + 1)}
          disabled={currentPage >= totalPages - 1}
        >
          <ChevronRight className="h-4 w-4" />
        </Button>
      </div>
    </div>
  );
}
```

Create `components/dynamic-query-table/detail-view.tsx`:

```typescript
"use client";

import React from "react";
import { Field } from "@/lib/types/field.types";
import { format } from "date-fns";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";

interface DetailViewProps {
  data: any;
  fields: Field[];
  open: boolean;
  onClose: () => void;
}

export function DetailView({ data, fields, open, onClose }: DetailViewProps) {
  const detailFields = fields.filter((f) => f.showInDetail);

  const getFieldValue = (field: Field, data: any): any => {
    const path = (field.accessor || field.name).split(".");
    let value = data;
    for (const key of path) {
      if (value && typeof value === "object") {
        value = value[key];
      } else {
        return null;
      }
    }
    return value;
  };

  const renderFieldValue = (field: Field, value: any) => {
    if (field.renderCell) {
      return field.renderCell(value, data);
    }

    if (value === null || value === undefined) {
      return <span className="text-muted-foreground">--</span>;
    }

    switch (field.type) {
      case "Boolean":
        return <span>{value ? "Yes" : "No"}</span>;

      case "Enum":
        return <span>{field.enumValues[value] || value}</span>;

      case "DateSec":
      case "DateTimeSec":
        try {
          const date = new Date(value * 1000);
          return <span>{format(date, "PPpp")}</span>;
        } catch {
          return <span>{value}</span>;
        }

      case "Date":
        try {
          const date = typeof value === "string" ? new Date(value) : value;
          return <span>{format(date, "PPpp")}</span>;
        } catch {
          return <span>{value}</span>;
        }

      case "Image":
        return (
          <div>
            <img
              src={value}
              alt={field.title}
              className="max-w-xs max-h-48 rounded border cursor-pointer hover:opacity-80"
              onClick={() => window.open(value, "_blank")}
            />
            <a
              href={value}
              target="_blank"
              rel="noopener noreferrer"
              className="text-xs text-blue-500 hover:underline block mt-1"
            >
              {value}
            </a>
          </div>
        );

      case "RichText":
        return (
          <div
            className="prose prose-sm max-w-none"
            dangerouslySetInnerHTML={{ __html: value }}
          />
        );

      default:
        return <span>{value.toString()}</span>;
    }
  };

  return (
    <Dialog open={open} onOpenChange={onClose}>
      <DialogContent className="max-w-2xl max-h-[80vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>Details</DialogTitle>
        </DialogHeader>
        <div className="space-y-4 mt-4">
          {detailFields.map((field) => {
            const value = getFieldValue(field, data);
            return (
              <div key={field.name} className="space-y-1">
                <div className="text-sm font-medium text-muted-foreground">
                  {field.title}
                </div>
                <div className="p-3 bg-muted/50 rounded-md">
                  {renderFieldValue(field, value)}
                </div>
              </div>
            );
          })}
        </div>
      </DialogContent>
    </Dialog>
  );
}
```

Create `components/dynamic-query-table/form.tsx`:

```typescript
"use client";

import React, { useEffect, useState } from "react";
import { Field } from "@/lib/types/field.types";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Checkbox } from "@/components/ui/checkbox";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from "@/components/ui/dialog";
import { format } from "date-fns";
import { Calendar } from "@/components/ui/calendar";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { CalendarIcon } from "lucide-react";
import { cn } from "@/lib/utils/cn";

interface FormProps {
  data?: any;
  fields: Field[];
  open: boolean;
  onClose: () => void;
  onSubmit: (data: any) => void | Promise<void>;
  idField?: string;
}

export function Form({
  data,
  fields,
  open,
  onClose,
  onSubmit,
  idField = "id",
}: FormProps) {
  const [formData, setFormData] = useState<any>({});
  const [modifiedFields, setModifiedFields] = useState<Set<string>>(new Set());
  const [isSubmitting, setIsSubmitting] = useState(false);

  const editableFields = fields.filter((f) => f.editable);

  useEffect(() => {
    if (data) {
      setFormData(data);
    } else {
      const defaults = editableFields.reduce((acc, field) => {
        if (field.defaultValue !== undefined) {
          acc[field.name] = field.defaultValue;
        }
        return acc;
      }, {} as any);
      setFormData(defaults);
    }
    setModifiedFields(new Set());
  }, [data, open]);

  const handleFieldChange = (fieldName: string, value: any) => {
    setFormData({ ...formData, [fieldName]: value });
    setModifiedFields(new Set(modifiedFields).add(fieldName));
  };

  const handleSubmit = async () => {
    setIsSubmitting(true);
    try {
      await onSubmit(formData);
      onClose();
    } catch (error) {
      console.error("Form submission error:", error);
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleRollback = () => {
    if (data) {
      setFormData(data);
    }
    setModifiedFields(new Set());
  };

  const getFieldValue = (field: Field): any => {
    return formData[field.name];
  };

  const renderFieldInput = (field: Field) => {
    const value = getFieldValue(field);

    if (field.renderEdit) {
      return field.renderEdit(value, (newValue) =>
        handleFieldChange(field.name, newValue)
      );
    }

    switch (field.type) {
      case "String":
        return (
          <Input
            value={value || ""}
            onChange={(e) => handleFieldChange(field.name, e.target.value)}
            placeholder={field.placeholder}
          />
        );

      case "Integer":
        return (
          <Input
            type="number"
            value={value || ""}
            onChange={(e) =>
              handleFieldChange(field.name, parseInt(e.target.value, 10) || 0)
            }
            placeholder={field.placeholder}
          />
        );

      case "Boolean":
        return (
          <div className="flex items-center space-x-2">
            <Checkbox
              id={`form-${field.name}`}
              checked={value || false}
              onCheckedChange={(checked) =>
                handleFieldChange(field.name, checked)
              }
            />
            <label htmlFor={`form-${field.name}`} className="text-sm">
              {field.title}
            </label>
          </div>
        );

      case "Enum":
        return (
          <Select
            value={value || undefined}
            onValueChange={(val) => handleFieldChange(field.name, val)}
          >
            <SelectTrigger>
              <SelectValue placeholder={`Select ${field.title}`} />
            </SelectTrigger>
            <SelectContent>
              {Object.entries(field.enumValues).map(([key, label]) => (
                <SelectItem key={key} value={key}>
                  {label}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        );

      case "Date":
        return (
          <Popover>
            <PopoverTrigger asChild>
              <Button
                variant="outline"
                className={cn(
                  "w-full justify-start text-left font-normal",
                  !value && "text-muted-foreground"
                )}
              >
                <CalendarIcon className="mr-2 h-4 w-4" />
                {value ? format(new Date(value), "PPP") : "Pick a date"}
              </Button>
            </PopoverTrigger>
            <PopoverContent className="w-auto p-0">
              <Calendar
                mode="single"
                selected={value ? new Date(value) : undefined}
                onSelect={(date) =>
                  handleFieldChange(field.name, date?.toISOString())
                }
              />
            </PopoverContent>
          </Popover>
        );

      case "DateSec":
      case "DateTimeSec":
        const dateValue = value ? new Date(value * 1000) : undefined;
        return (
          <Popover>
            <PopoverTrigger asChild>
              <Button
                variant="outline"
                className={cn(
                  "w-full justify-start text-left font-normal",
                  !value && "text-muted-foreground"
                )}
              >
                <CalendarIcon className="mr-2 h-4 w-4" />
                {value ? format(dateValue!, "PPP") : "Pick a date"}
              </Button>
            </PopoverTrigger>
            <PopoverContent className="w-auto p-0">
              <Calendar
                mode="single"
                selected={dateValue}
                onSelect={(date) =>
                  handleFieldChange(
                    field.name,
                    date ? Math.floor(date.getTime() / 1000) : null
                  )
                }
              />
            </PopoverContent>
          </Popover>
        );

      case "Image":
        return (
          <div className="space-y-2">
            <Input
              type="file"
              accept={field.allowedTypes?.join(",") || "image/*"}
              onChange={async (e) => {
                const file = e.target.files?.[0];
                if (file) {
                  handleFieldChange(field.name, file.name);
                }
              }}
            />
            {value && (
              <img
                src={value}
                alt={field.title}
                className="max-w-xs max-h-32 rounded border"
              />
            )}
          </div>
        );

      case "RichText":
        return (
          <textarea
            className="flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50"
            value={value || ""}
            onChange={(e) => handleFieldChange(field.name, e.target.value)}
            placeholder={field.placeholder}
            rows={5}
          />
        );

      default:
        return (
          <Input
            value={value || ""}
            onChange={(e) => handleFieldChange(field.name, e.target.value)}
            placeholder={field.placeholder}
          />
        );
    }
  };

  const isNewRecord = !data || !data[idField];

  return (
    <Dialog open={open} onOpenChange={onClose}>
      <DialogContent className="max-w-2xl max-h-[80vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>
            {isNewRecord ? "Create New Record" : "Edit Record"}
          </DialogTitle>
        </DialogHeader>

        <div className="space-y-4 mt-4">
          {editableFields.map((field) => {
            const isModified = modifiedFields.has(field.name);
            return (
              <div key={field.name} className="space-y-2">
                {field.type !== "Boolean" && (
                  <Label htmlFor={`form-${field.name}`}>
                    {isModified && <span className="text-orange-500">* </span>}
                    {field.title}
                  </Label>
                )}
                {renderFieldInput(field)}
              </div>
            );
          })}
        </div>

        <DialogFooter className="gap-2">
          {!isNewRecord && modifiedFields.size > 0 && (
            <Button variant="outline" onClick={handleRollback}>
              Rollback Changes
            </Button>
          )}
          <Button onClick={handleSubmit} disabled={isSubmitting}>
            {isSubmitting
              ? "Saving..."
              : isNewRecord
              ? "Create"
              : "Save Changes"}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
```

Create `components/dynamic-query-table/table.tsx`:

```typescript
"use client";

import React, { useEffect, useState, useCallback } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { ArrowUpDown, Eye, RefreshCw, Settings2 } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Checkbox } from "@/components/ui/checkbox";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Badge } from "@/components/ui/badge";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { Field, SpringPage, CriteriaOperation } from "@/lib/types/field.types";
import { QueryBuilder } from "@/lib/utils/query-builder";
import { FilterPanel } from "./filter";
import { Pagination } from "./pagination";
import { DetailView } from "./detail-view";
import { Form } from "./form";
import { format } from "date-fns";
import { cn } from "@/lib/utils/cn";

interface DynamicQueryTableProps<T = any> {
  fields: Field[];
  apiUrl: string;
  idField?: string;
  defaultSortField?: string;
  pageSize?: number;
  enableFilter?: boolean;
  enableSelection?: boolean;
  enableCreate?: boolean;
  enableEdit?: boolean;
  onRowSelect?: (rows: T[]) => void;
  onDataChange?: (data: SpringPage<T>) => void;
}

export function DynamicQueryTable<T = any>({
  fields,
  apiUrl,
  idField = "id",
  defaultSortField = "id",
  pageSize = 20,
  enableFilter = true,
  enableSelection = false,
  enableCreate = false,
  enableEdit = false,
  onRowSelect,
  onDataChange,
}: DynamicQueryTableProps<T>) {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [data, setData] = useState<SpringPage<T> | null>(null);
  const [loading, setLoading] = useState(false);
  const [selectedRows, setSelectedRows] = useState<Set<any>>(new Set());
  const [queryBuilder, setQueryBuilder] = useState<QueryBuilder>(
    new QueryBuilder()
  );
  const [detailData, setDetailData] = useState<T | null>(null);
  const [formData, setFormData] = useState<T | null | undefined>(undefined);
  const [columnVisibility, setColumnVisibility] = useState<Record<string, boolean>>({});

  useEffect(() => {
    const visibility = fields.reduce((acc, field) => {
      acc[field.name] = field.visible !== false;
      return acc;
    }, {} as Record<string, boolean>);
    setColumnVisibility(visibility);
  }, [fields]);

  useEffect(() => {
    const queryString = searchParams.toString();
    if (queryString) {
      const builder = new QueryBuilder();
      builder.fromQueryString(queryString);
      setQueryBuilder(builder);
    } else {
      const builder = new QueryBuilder();
      builder.setPage(0);
      builder.setPageSize(pageSize);
      builder.setSort(defaultSortField, "desc");
      setQueryBuilder(builder);
    }
  }, []);

  useEffect(() => {
    if (queryBuilder.query) {
      fetchData();
    }
  }, [queryBuilder]);

  const updateUrl = useCallback(() => {
    const queryString = queryBuilder.toQueryString();
    router.replace(`?${queryString}`, { scroll: false });
  }, [queryBuilder, router]);

  const fetchData = async () => {
    setLoading(true);
    try {
      const queryString = queryBuilder.toQueryString();
      const response = await fetch(`${apiUrl}?${queryString}`);
      if (!response.ok) {
        throw new Error("Failed to fetch data");
      }
      const result: SpringPage<T> = await response.json();
      setData(result);
      setSelectedRows(new Set());
      if (onDataChange) {
        onDataChange(result);
      }
    } catch (error) {
      console.error("Error fetching data:", error);
    } finally {
      setLoading(false);
    }
  };

  const handleFilterChange = () => {
    queryBuilder.setPage(0);
    setQueryBuilder(new QueryBuilder(queryBuilder.query));
    updateUrl();
  };

  const handlePageChange = (page: number) => {
    queryBuilder.setPage(page);
    setQueryBuilder(new QueryBuilder(queryBuilder.query));
    updateUrl();
  };

  const handlePageSizeChange = (newPageSize: number) => {
    queryBuilder.setPageSize(newPageSize);
    queryBuilder.setPage(0);
    setQueryBuilder(new QueryBuilder(queryBuilder.query));
    updateUrl();
  };

  const handleSort = (field: Field) => {
    if (field.sortable === false) return;

    const fieldName = field.accessor || field.name;
    const currentSort = queryBuilder.query.orderBy?.[0];
    const currentDirection = queryBuilder.query.orderByDirection?.[0];

    let newDirection: "asc" | "desc" = "desc";
    if (currentSort === fieldName && currentDirection === "desc") {
      newDirection = "asc";
    }

    queryBuilder.setSort(fieldName, newDirection);
    setQueryBuilder(new QueryBuilder(queryBuilder.query));
    updateUrl();
  };

  const handleSelectAll = (checked: boolean) => {
    if (checked && data) {
      const allIds = data.content.map((row: any) => row[idField]);
      setSelectedRows(new Set(allIds));
      if (onRowSelect) {
        onRowSelect(data.content);
      }
    } else {
      setSelectedRows(new Set());
      if (onRowSelect) {
        onRowSelect([]);
      }
    }
  };

  const handleRowSelect = (id: any, checked: boolean) => {
    const newSelection = new Set(selectedRows);
    if (checked) {
      newSelection.add(id);
    } else {
      newSelection.delete(id);
    }
    setSelectedRows(newSelection);
    if (onRowSelect && data) {
      const selected = data.content.filter((row: any) =>
        newSelection.has(row[idField])
      );
      onRowSelect(selected);
    }
  };

  const handleClearFilters = () => {
    queryBuilder.clearCriteria();
    queryBuilder.setPage(0);
    queryBuilder.setPageSize(pageSize);
    queryBuilder.setSort(defaultSortField, "desc");
    setQueryBuilder(new QueryBuilder(queryBuilder.query));
    updateUrl();
  };

  const handleFormSubmit = async (formData: any) => {
    console.log("Form submitted:", formData);
    await fetchData();
  };

  const getFieldValue = (row: any, field: Field): any => {
    const path = (field.accessor || field.name).split(".");
    let value = row;
    for (const key of path) {
      if (value && typeof value === "object") {
        value = value[key];
      } else {
        return null;
      }
    }
    return value;
  };

  const renderCellValue = (field: Field, value: any, row: any) => {
    if (field.renderCell) {
      return field.renderCell(value, row);
    }

    if (value === null || value === undefined) {
      return <span className="text-muted-foreground">--</span>;
    }

    switch (field.type) {
      case "Boolean":
        return <Badge variant={value ? "default" : "secondary"}>{value ? "Yes" : "No"}</Badge>;

      case "Enum":
        return <span>{field.enumValues[value] || value}</span>;

      case "DateSec":
      case "DateTimeSec":
        try {
          const date = new Date(value * 1000);
          return <span>{format(date, "PPp")}</span>;
        } catch {
          return <span>{value}</span>;
        }

      case "Date":
        try {
          const date = typeof value === "string" ? new Date(value) : value;
          return <span>{format(date, "PPp")}</span>;
        } catch {
          return <span>{value}</span>;
        }

      case "Image":
        return (
          <img
            src={value}
            alt={field.title}
            className="h-10 w-10 object-cover rounded"
          />
        );

      case "RichText":
        const stripped = value.replace(/<[^>]*>/g, "").substring(0, 50);
        return <span>{stripped}...</span>;

      default:
        const text = value.toString();
        if (text.length > 50) {
          return (
            <span title={text}>
              {text.substring(0, 50)}...
            </span>
          );
        }
        return <span>{text}</span>;
    }
  };

  const visibleFields = fields.filter((f) => columnVisibility[f.name]);
  const currentSort = queryBuilder.query.orderBy?.[0];
  const currentDirection = queryBuilder.query.orderByDirection?.[0];

  return (
    <div className="space-y-4">
      {enableFilter && (
        <FilterPanel
          fields={fields}
          queryBuilder={queryBuilder}
          onFilterChange={handleFilterChange}
        />
      )}

      <div className="flex items-center justify-between">
        <div className="flex items-center gap-2">
          {enableCreate && (
            <Button onClick={() => setFormData(null)}>
              Create New
            </Button>
          )}
          <Button
            variant="outline"
            size="icon"
            onClick={() => fetchData()}
            disabled={loading}
          >
            <RefreshCw className={cn("h-4 w-4", loading && "animate-spin")} />
          </Button>
          {enableFilter && (
            <Button variant="outline" onClick={handleClearFilters}>
              Clear Filters
            </Button>
          )}
        </div>

        <Popover>
          <PopoverTrigger asChild>
            <Button variant="outline" size="icon">
              <Settings2 className="h-4 w-4" />
            </Button>
          </PopoverTrigger>
          <PopoverContent className="w-56">
            <div className="space-y-3">
              <div className="flex items-center justify-between">
                <div className="font-medium text-sm">Column Visibility</div>
                <div className="flex gap-1">
                  <Button
                    variant="ghost"
                    size="sm"
                    className="h-7 text-xs"
                    onClick={() => {
                      const allVisible = fields.reduce((acc, field) => {
                        acc[field.name] = true;
                        return acc;
                      }, {} as Record<string, boolean>);
                      setColumnVisibility(allVisible);
                    }}
                  >
                    All
                  </Button>
                  <Button
                    variant="ghost"
                    size="sm"
                    className="h-7 text-xs"
                    onClick={() => {
                      const allHidden = fields.reduce((acc, field) => {
                        acc[field.name] = false;
                        return acc;
                      }, {} as Record<string, boolean>);
                      setColumnVisibility(allHidden);
                    }}
                  >
                    None
                  </Button>
                </div>
              </div>
              <div className="space-y-2">
                {fields.map((field) => (
                  <div key={field.name} className="flex items-center space-x-2">
                    <Checkbox
                      id={`col-${field.name}`}
                      checked={columnVisibility[field.name]}
                      onCheckedChange={(checked) =>
                        setColumnVisibility({
                          ...columnVisibility,
                          [field.name]: checked as boolean,
                        })
                      }
                    />
                    <label
                      htmlFor={`col-${field.name}`}
                      className="text-sm cursor-pointer"
                    >
                      {field.title}
                    </label>
                  </div>
                ))}
              </div>
            </div>
          </PopoverContent>
        </Popover>
      </div>

      <div className="border rounded-lg">
        <Table>
          <TableHeader>
            <TableRow>
              {enableSelection && (
                <TableHead className="w-12">
                  <Checkbox
                    checked={
                      data &&
                      data.content.length > 0 &&
                      selectedRows.size === data.content.length
                    }
                    onCheckedChange={handleSelectAll}
                  />
                </TableHead>
              )}
              {visibleFields.map((field) => (
                <TableHead
                  key={field.name}
                  className={cn(field.sortable !== false && "cursor-pointer")}
                  onClick={() => handleSort(field)}
                >
                  <div className="flex items-center gap-2">
                    {field.title}
                    {field.sortable !== false && (
                      <ArrowUpDown
                        className={cn(
                          "h-4 w-4",
                          currentSort === (field.accessor || field.name) &&
                            "text-primary"
                        )}
                      />
                    )}
                  </div>
                </TableHead>
              ))}
              <TableHead className="w-24">Actions</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {loading ? (
              <TableRow>
                <TableCell
                  colSpan={
                    visibleFields.length + (enableSelection ? 2 : 1)
                  }
                  className="text-center h-24"
                >
                  Loading...
                </TableCell>
              </TableRow>
            ) : data && data.content.length > 0 ? (
              data.content.map((row: any) => {
                const rowId = row[idField];
                const isSelected = selectedRows.has(rowId);
                return (
                  <TableRow
                    key={rowId}
                    data-state={isSelected && "selected"}
                  >
                    {enableSelection && (
                      <TableCell>
                        <Checkbox
                          checked={isSelected}
                          onCheckedChange={(checked) =>
                            handleRowSelect(rowId, checked as boolean)
                          }
                        />
                      </TableCell>
                    )}
                    {visibleFields.map((field) => (
                      <TableCell key={field.name}>
                        {renderCellValue(field, getFieldValue(row, field), row)}
                      </TableCell>
                    ))}
                    <TableCell>
                      <div className="flex items-center gap-2">
                        <Button
                          variant="ghost"
                          size="icon"
                          onClick={() => setDetailData(row)}
                        >
                          <Eye className="h-4 w-4" />
                        </Button>
                        {enableEdit && (
                          <Button
                            variant="ghost"
                            size="icon"
                            onClick={() => setFormData(row)}
                          >
                            Edit
                          </Button>
                        )}
                      </div>
                    </TableCell>
                  </TableRow>
                );
              })
            ) : (
              <TableRow>
                <TableCell
                  colSpan={
                    visibleFields.length + (enableSelection ? 2 : 1)
                  }
                  className="text-center h-24"
                >
                  No results found
                </TableCell>
              </TableRow>
            )}
          </TableBody>
        </Table>
      </div>

      {data && data.totalElements > 0 && (
        <Pagination
          page={data}
          onPageChange={handlePageChange}
          onPageSizeChange={handlePageSizeChange}
        />
      )}

      {detailData && (
        <DetailView
          data={detailData}
          fields={fields}
          open={!!detailData}
          onClose={() => setDetailData(null)}
        />
      )}

      {formData !== undefined && (
        <Form
          data={formData}
          fields={fields}
          open={formData !== undefined}
          onClose={() => setFormData(undefined)}
          onSubmit={handleFormSubmit}
          idField={idField}
        />
      )}
    </div>
  );
}
```

Create `components/dynamic-query-table/index.ts`:

```typescript
export { DynamicQueryTable } from "./table";
export { FilterPanel } from "./filter";
export { Pagination } from "./pagination";
export { DetailView } from "./detail-view";
export { Form } from "./form";
```

## Step 11: Update Root Layout

Create or update `app/layout.tsx`:

```typescript
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Spring Dynamic Query UI",
  description: "A modern UI library for Spring Dynamic Query",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  );
}
```

## Step 12: Create Example API Route (Optional for Testing)

Create `app/api/gifts/route.ts`:

```typescript
import { NextRequest, NextResponse } from "next/server";
import { SpringPage } from "@/lib/types/field.types";

const mockData = Array.from({ length: 100 }, (_, i) => ({
  id: i + 1,
  discountCode: `GIFT${String(i + 1).padStart(3, "0")}`,
  showName: `Gift Card ${i + 1}`,
  reason: i % 3 === 0 ? "Bulk Creation" : i % 3 === 1 ? "Manual" : "Import",
  imageUrl: `https://picsum.photos/200?random=${i}`,
  description: `<p>Sample gift card description for <strong>Gift Card ${i + 1}</strong></p>`,
  codeType: ["NORMAL", "SECOND_ITEM_PERCENTAGE", "ADD_X_ITEM_PERCENTAGE"][i % 3],
  minimumBasketItemCount: i % 2 === 0 ? 2 : 5,
  beginDate: Math.floor(Date.now() / 1000) - (i * 86400),
  endDate: Math.floor(Date.now() / 1000) + ((100 - i) * 86400),
  type: i % 2 === 0 ? "1" : "2",
  showLocation: ["NONE", "PRODUCT_DETAIL", "BASKET", "BASKET_AND_PRODUCT_DETAIL"][i % 4],
  showCountry: ["TURKEY", "UNITED_KINGDOM", "NON_TURKEY", "ALL"][i % 4],
  active: i % 3 !== 0,
  createDate: Math.floor(Date.now() / 1000) - (i * 172800),
}));

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;

  const page = parseInt(searchParams.get("page") || "0", 10);
  const pageSize = parseInt(searchParams.get("pageSize") || "20", 10);

  let filteredData = [...mockData];

  const criteriaKeys = Array.from(searchParams.keys()).filter((key) =>
    key.startsWith("key")
  );

  criteriaKeys.forEach((keyParam) => {
    const index = keyParam.replace("key", "");
    const key = searchParams.get(keyParam);
    const operation = searchParams.get(`operation${index}`);
    const values = searchParams.getAll(`values${index}`);

    if (!key || !operation || values.length === 0) return;

    filteredData = filteredData.filter((item: any) => {
      const itemValue = item[key];

      switch (operation) {
        case "CONTAIN":
          return itemValue
            ?.toString()
            .toLowerCase()
            .includes(values[0].toLowerCase());
        case "EQUAL":
          return values.some((v) => itemValue?.toString() === v);
        case "GREATER_THAN":
          return itemValue > parseFloat(values[0]);
        case "GREATER_THAN_OR_EQUAL":
          return itemValue >= parseFloat(values[0]);
        case "LESS_THAN":
          return itemValue < parseFloat(values[0]);
        case "LESS_THAN_OR_EQUAL":
          return itemValue <= parseFloat(values[0]);
        case "SPECIFIED":
          return itemValue !== null && itemValue !== undefined;
        default:
          return true;
      }
    });
  });

  const orderBy = searchParams.get("orderBy0");
  const orderByDirection = searchParams.get("orderByDirection0") || "desc";

  if (orderBy) {
    filteredData.sort((a: any, b: any) => {
      const aVal = a[orderBy];
      const bVal = b[orderBy];

      if (aVal === bVal) return 0;

      const comparison = aVal > bVal ? 1 : -1;
      return orderByDirection === "asc" ? comparison : -comparison;
    });
  }

  const start = page * pageSize;
  const end = start + pageSize;
  const paginatedData = filteredData.slice(start, end);

  const response: SpringPage<any> = {
    content: paginatedData,
    pageable: {
      pageNumber: page,
      pageSize: pageSize,
      sort: {
        sorted: !!orderBy,
        unsorted: !orderBy,
        empty: !orderBy,
      },
      offset: start,
      paged: true,
      unpaged: false,
    },
    totalPages: Math.ceil(filteredData.length / pageSize),
    totalElements: filteredData.length,
    last: end >= filteredData.length,
    size: pageSize,
    number: page,
    sort: {
      sorted: !!orderBy,
      unsorted: !orderBy,
      empty: !orderBy,
    },
    numberOfElements: paginatedData.length,
    first: page === 0,
    empty: paginatedData.length === 0,
  };

  return NextResponse.json(response);
}
```

## Step 13: Create Example Page

Create `app/example/page.tsx`:

```typescript
"use client";

import React from "react";
import { DynamicQueryTable } from "@/components/dynamic-query-table";
import { Field } from "@/lib/types/field.types";

export default function ExamplePage() {
  const fields: Field[] = [
    {
      name: "id",
      title: "ID",
      type: "Integer",
      visible: true,
      filterable: true,
      sortable: true,
      showInDetail: true,
      editable: false,
    },
    {
      name: "discountCode",
      title: "Discount Code",
      type: "String",
      visible: true,
      filterable: true,
      sortable: true,
      showInDetail: true,
      editable: true,
      placeholder: "Enter discount code...",
    },
    {
      name: "showName",
      title: "Display Name",
      type: "String",
      visible: true,
      filterable: true,
      sortable: true,
      showInDetail: true,
      editable: true,
    },
    {
      name: "type",
      title: "Discount Type",
      type: "Enum",
      enumValues: {
        "1": "Fixed",
        "2": "Percentage",
      },
      visible: true,
      filterable: true,
      sortable: true,
      showInDetail: true,
      editable: true,
    },
    {
      name: "active",
      title: "Active",
      type: "Boolean",
      visible: true,
      filterable: true,
      sortable: true,
      showInDetail: true,
      editable: true,
    },
    {
      name: "beginDate",
      title: "Start Date",
      type: "DateTimeSec",
      visible: true,
      filterable: true,
      sortable: true,
      showInDetail: true,
      editable: true,
    },
    {
      name: "endDate",
      title: "End Date",
      type: "DateTimeSec",
      visible: true,
      filterable: true,
      sortable: true,
      showInDetail: true,
      editable: true,
    },
  ];

  return (
    <div className="container mx-auto py-10">
      <div className="mb-8">
        <h1 className="text-3xl font-bold mb-2">Spring Dynamic Query Table Example</h1>
        <p className="text-muted-foreground">
          This example demonstrates the DynamicQueryTable component with various field types.
          All query parameters are synced with the URL and match the Spring Dynamic Query format.
        </p>
      </div>

      <DynamicQueryTable
        fields={fields}
        apiUrl="/api/gifts"
        enableFilter={true}
        enableSelection={true}
        enableCreate={true}
        enableEdit={true}
        pageSize={20}
        defaultSortField="id"
        onRowSelect={(rows) => {
          console.log("Selected rows:", rows);
        }}
        onDataChange={(data) => {
          console.log("Data changed:", data);
        }}
      />
    </div>
  );
}
```

## Step 14: Run the Application

Start the development server:

```bash
npm run dev
```

Navigate to `http://localhost:3000/example` to see the Dynamic Query Table in action.

## Field Type Configuration Reference

### Field Properties

All field types support these base properties:

- `name` (required): Field identifier matching backend property
- `title` (required): Display label
- `type` (required): Field type (String, Integer, Boolean, Date, DateSec, DateTimeSec, Enum, Image, RichText)
- `visible`: Show column in table (default: true)
- `filterable`: Enable filtering (default: false)
- `sortable`: Enable sorting (default: false)
- `showInDetail`: Show in detail view (default: false)
- `editable`: Allow editing in form (default: false)
- `accessor`: Alternative field path for nested data
- `placeholder`: Input placeholder text
- `defaultValue`: Default value for new records
- `renderCell`: Custom cell renderer function
- `renderEdit`: Custom edit input renderer function

### String Field

```typescript
{
  name: "username",
  title: "Username",
  type: "String",
  filterable: true,
  sortable: true,
  editable: true,
  placeholder: "Enter username..."
}
```

Filter operation: CONTAIN

### Integer Field

```typescript
{
  name: "age",
  title: "Age",
  type: "Integer",
  filterable: true,
  sortable: true,
  editable: true
}
```

Filter operation: EQUAL

### Boolean Field

```typescript
{
  name: "active",
  title: "Active",
  type: "Boolean",
  filterable: true,
  sortable: true,
  editable: true
}
```

Filter operation: SPECIFIED

### Enum Field

```typescript
{
  name: "status",
  title: "Status",
  type: "Enum",
  enumValues: {
    "ACTIVE": "Active",
    "INACTIVE": "Inactive",
    "PENDING": "Pending"
  },
  filterable: true,
  sortable: true,
  editable: true
}
```

Filter operation: EQUAL (supports multiple values)

### Date Fields

DateSec and DateTimeSec use Unix timestamps in seconds:

```typescript
{
  name: "createdAt",
  title: "Created At",
  type: "DateTimeSec",
  filterable: true,
  sortable: true,
  editable: true
}
```

Filter operations: GREATER_THAN_OR_EQUAL and LESS_THAN_OR_EQUAL for range filtering

### Image Field

```typescript
{
  name: "avatar",
  title: "Avatar",
  type: "Image",
  uploadConfig: "user-avatar",
  maxSize: 5242880,
  allowedTypes: ["image/jpeg", "image/png"],
  showInDetail: true,
  editable: true
}
```

### RichText Field

```typescript
{
  name: "description",
  title: "Description",
  type: "RichText",
  showInDetail: true,
  editable: true
}
```

## Spring Backend URL Format

The component generates URL parameters matching Spring Dynamic Query format:

```
?key0=username&operation0=CONTAIN&values0=john&key1=age&operation1=EQUAL&values1=25&page=0&pageSize=20&orderBy0=id&orderByDirection0=desc
```

## Troubleshooting

### shadcn/ui components not working

Ensure you've installed all required components:
```bash
npx shadcn-ui@latest add badge button calendar checkbox dialog input label popover select table
```

### Type errors

Make sure TypeScript paths are configured correctly in `tsconfig.json`:
```json
"paths": {
  "@/*": ["./*"]
}
```

### Styling issues

Verify that `globals.css` is imported in your root layout and contains the CSS variables.

## Installation Complete

You now have a fully functional Spring Dynamic Query UI setup. The component will automatically sync all filters, sorting, and pagination with the URL, making it easy to share filtered views and bookmark specific states.
